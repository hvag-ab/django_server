from django.contrib.auth.models import User, Group
from rest_framework import serializers
from restful.models import Article,Tag
from django.contrib.contenttypes.models import ContentType
from rest_framework.validators import UniqueValidator, UniqueTogetherValidator
import re


### 注意 关联字段 不作为参数验证  一定要排除

""""
1、序列化queryset数据

2、反序列化json数据，将反序列化后的数据转换成model对象

3、反序列化的时候还是可以对数据做校验

4、如果合法，可以调用save方法进行post或者put请求操作

5、如果不合法，则返回错误
"""


#read_only：True表示不允许用户自己上传，只能用于api的输出。如果某个字段设置了
#write_only: 与read_only对应
"""
write_only: 与read_only对应
required: 顾名思义，就是这个字段是否必填。
allow_null/allow_blank：是否允许为NULL/空 。
error_messages：出错时，信息提示。

name = serializers.CharField(required=True, min_length=6,
                error_messages={
                    'min_length': '名字不能小于6个字符',
                    'required': '请填写名字'})
label: 字段显示设置，如 label=’验证码’
help_text: 在指定字段增加一些提示文字，这两个字段作用于api页面比较有用
style: 说明字段的类型，这样看可能比较抽象，看下面例子：

"""

# 假设现在是个博客，有一个创建文章，与修改文章的功能, model为Article。
class ArticleSerializer(serializers.Serializer):
    user = serializers.HiddenField(
        default=serializers.CurrentUserDefault())
    username = serializers.CharField(
        max_length=11,
        min_length=11,
        validators=[UniqueValidator(queryset=UserProfile.objects.all())])
    lis = serializers.ListField(serializers.CharField(max_length=9), max_length=100, min_length=0)
    age = serializers.IntegerField(min_value=1, max_value=100,error_messages={'required':'age不能为空'})
    # format可以设置时间的格式，下面例子会输出如:2018-1-24 12:10
    pay_time = serializers.DateTimeField(read_only=True, format='%Y-%m-%d %H:%M')
    is_hot = serializers.BooleanField(required = False)
    defualt_field = serializers.CharField(default="hvag",allow_blank=False)
    money = serializers.DecimalField(max_digits=6, decimal_places=4)
    #EmailField RegexField  URLField  FilePathField IPAddressField
    cho = serializers.ChoiceField(choices=((1,'h'),(2,'y')))
    js = serializers.JSONField()
    fid = serializers.PrimaryKeyRelatedField()

    mobile_phone = serializers.CharField(max_length=11, min_length=11)

    start = serializers.DateTimeField()
    finish = serializers.DateTimeField()

    order_sn = serializers.CharField(read_only=True)

    def create(self, validated_data):
    # 除了用户，其他数据可以从validated_data这个字典中获取
    # 注意，users在这里是放在上下文中的request，而不是直接的request 在序列化的时候 需要加入comtext = request 否则拿不到request
    # 例如 serializer = SnippetSerializer(data=request.data, context={'request':request})
        user = self.context['request'].user
        name = validated_data['name ']
        content = validated_data['content ']

        instance = super().create(**validated_data)
        return instance

    def update(self, instance, validated_data):
    # 更新的特别之处在于你已经获取到了这个对象instance
        instance.name = validated_data.get('name',instance.name)
        instance.content = validated_data.get('content', instance.content)
        instance.save()
        return instance


    def validate_mobile_phone(self, mobile_phone):##验证单个字段
        # 注意参数，self以及字段名
        # 注意函数名写法，validate_ + 字段名字
        if not re.match(REGEX_MOBILE, mobile):
            # REGEX_MOBILE表示手机的正则表达式
            raise serializers.ValidationError("手机号码非法")
        return mobile_phone

    def validate(self, data): ## data是传进来的参数 里面获取上面定义好的字段进行字段之间的验证，或者生成只读字段
        # 传进来什么参数，就返回什么参数，一般情况下用attrs
        if data['start'] > data['finish']:
            raise serializers.ValidationError("finish must occur after start")

        data['order_sn'] = generate_order_sn() ##生成只读字段记录
        return data

    class Meta:
        validators = [
            UniqueTogetherValidator(
                queryset=Article.objects.all(),
                fields=('mobile_phone', 'username'),
                message='已经收藏'
            )]


# 含有外键的保存与更新

class UserSerializer(serializers.ModelSerializer):
    # 这里的外键包含OneToOneField ForeignKey  ManyToManyField
    profile = ProfileSerializer() # 首先关联的模型序列化例如ProfileSerializer,其次在序列化的时候对应的外键字段如左边这样

    class Meta:
        model = User
        fields = ['username', 'email', 'profile']

    def create(self, validated_data):
        profile_data = validated_data.pop('profile')
        user = User.objects.create(**validated_data)
        Profile.objects.create(user=user, **profile_data)
        return user

    def update(self, instance, validated_data):
        profile_data = validated_data.pop('profile')
        # Unless the application properly enforces that this field is
        # always set, the following could raise a `DoesNotExist`, which
        # would need to be handled.
        profile = instance.profile

        instance.username = validated_data.get('username', instance.username)
        instance.email = validated_data.get('email', instance.email)
        instance.save()

        profile.is_premium_member = profile_data.get(
            'is_premium_member',
            profile.is_premium_member
        )
        profile.has_support_contract = profile_data.get(
            'has_support_contract',
            profile.has_support_contract
        )
        profile.save()

        return instance

# 序列化嵌套模式  主要要重写create 或者 update  如果外键反序列化不做处理 那么反序列户的时候就会报错
# serializer = CommentSerializer(data={'user': {'email': 'foobar', 'username': 'doe'}, 'content': 'baz'})
# serializer.is_valid()
# # False
# serializer.errors
# # {'user': {'email': ['Enter a valid e-mail address.']}, 'created': ['This field is required.']}



class ArticlesSerializer(serializers.ModelSerializer):#类似于forms.ModelForm
    # ForeignKey 链表结构字段处理，有两种处理方式，第一种展示 serializer 中设置的字段，
    # 第一种方name法 author = UserSerializer()
    # 第二种展示某个指定字段
    author_name = serializers.ReadOnlyField(source='author.username')#auth 是 Article的外键字段 meta fields必须包含这个字段
    # ManyToMany OneToOneField ForeignKey都适用
    tags = TagSerializer(many=True, read_only=True)## 展示tag的字段 必须也要序列化tag模型  如果外键关联的表有多个字段时，需要设置子序列化字段many=True。

    author = serializers.HiddenField(
        default=serializers.CurrentUserDefault()#直接写入author ，不可读
    )
    ##某个字段不属于指定model，它是read_only，只需要将它序列化传递给用户，但是在这个
    article_comments_count = serializers.SerializerMethodField()#因为comment_count字段 在Article中不存在 而comment字段存在 需要自定义一个方法get_comment_count 实际是获取了comment这个字段

    req = serializers.SerializerMethodField('reqq')

    def get_article_comments_count(self, obj):##必须定义 get_{filed_name} 为了SerializerMethodField获取这个filed_name,这个filed_name 是自定义的一个serializer对象
        return obj.article_comments.all().count()#因为这个参数related_name="comment" 反向查询 这里的obj是Article单条记录对象

    hvag = serializers.CharField(read_only=True) #如果一个serializer中，要包含出了model以外的字段

    class Meta:
        model = Article
        fields = "__all__"
        # fields = []: 表示筛选字段
        # exclude = ('add_time',):  除去指定的某些字段
        # 这三种方式，存在一个即可
        # 表示连表的深度
        depth = 1
        read_only_fields = ('account_name',)
        extra_kwargs = {'password': {'write_only': True}}

    def reqq(self,obj):

        request = self.context['request']#获得request对象 目的是为了获取request的传入的参数
        params = self.request.query_params  # 这个主要是获取get传入的参数 例如json?name=hvag
        #do something
        pass

    def validate(self, attrs):
        """
        某个字段不属于指定model，它是write_only，需要用户传进来，但我们不能对它进行save( )，
        因为ModelSerializer是基于Model，这个字段在Model中没有对应，这个时候，我们需要重载validate

        """
        del attrs["code"]
        return attrs

class PasswordResetConfirmSerializer(serializers.Serializer):

    username = serializers.CharField(max_length=255)
    new_password1 = serializers.CharField(max_length=128)
    new_password2 = serializers.CharField(max_length=128)
    email = serializers.EmailField()

    def validate(self, attrs):

        if attrs.get('new_password1') != attrs.get('new_password2'):
            raise exceptions.ValidationError({"password_error": "两次密码不一致"})
        username = attrs.get('username')
        email = attrs.get('email')
        user = User.objects.filter(username=username,email=email).first()
        if not user:
            raise serializers.ValidationError('用户名或者邮箱存在错误')
        attrs['user'] = user# 传递数据
        return attrs

    def save(self):# save并不一定是用来create或者 update 可以用来实现自己的逻辑
        request = self.context.get('request')
        token = request.query_params.get('token')
        user = self.validated_data['user']
        instance = FindPwdRecord.objects.filter(token = token,username=user.username,email=user.email)
        obj = instance.first()
        if not obj:
            raise serializers.ValidationError('token 失效')
        now = datetime.now()
        create_time = obj.create_time
        expiry_time = timedelta(seconds=obj.expiry_time)
        if create_time + expiry_time <= now:
            raise serializers.ValidationError('token 过期')
        obj.delete()
        password = make_password(self.validated_data['new_password1'])
        User.objects.filter(username=user.username).update(password=password)



class PasswordValidator(object):
    def __init__(self, base):
        self.base = base

    def __call__(self, value):
        if value != self.base:
            message = '用户输入的值必须是 %s.' % self.base
            raise serializers.ValidationError(message)

    def set_context(self, serializer_field):
        """
        This hook is called by the serializer instance,
        prior to the validation call being made.
        """
        # 执行验证之前调用,serializer_fields是当前字段对象
        pass

class UsersSerializer(serializers.ModelSerializer):
    pwd = serializers.CharField(validators=[PasswordValidator(666), ])

    class Meta:
        model = models.UserInfo
        fields = "__all__"
        #自定义验证规则
        extra_kwargs = {
            'name': {'min_length': 6},
            'pwd': {'validators': [PasswordValidator(666), ]}
        }

#超链接显示api 注意对应关系
class ProfileSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Profile
        # HyperlinkedModelSerializer 会自动生成一个 url 字段来表示超链接
        # 我们希望 API 中包括这个字段，所以这里我们在 fields 加上
        fields = ('url', 'city', 'owner')

        # 我们可以在 extra_kwargs 设置中的 view_name 和 lookup_field
        # 来正确配置我们的 URL
        # view_name 和 urls.py 中的 name 参数相对应，表示使用哪个 url
        # lookup_field 表示用哪个字段来作为 url 的唯一识别标记
        # 本例中每个 Profile 的 url 是通过 id 来区分的，所以该字段用 id
        extra_kwargs = {
            'url': {'view_name': 'profile-detail', 'lookup_field': 'id'},
            'owner': {'lookup_field': 'id'}
        }


class UserSerializer(serializers.HyperlinkedModelSerializer):
    user_profile = ProfileSerializer()

    class Meta:
        model = User
        fields = ('url', 'username', 'email', 'user_profile')

        extra_kwargs = {
            'url': {'view_name': 'user-detail', 'lookup_field': 'id'},
        }

#递归
parent_category = models.ForeignKey('self', null=True, blank=True,
                    verbose_name='父类目别',
                    related_name='sub_cat')

courses = SerializerMethodField()
def get_courses(self, obj):
    all_courses = Course.objects.filter(category__parent_category_id=obj.id)
    courses_serializer = CourseSerializer(all_course, many=True,
                    context={'request': self.context['request']})
    return courses_serializer.data


"""
参数名称	说明
read_only	表明该字段仅用于序列化输出，默认False
write_only	表明该字段仅用于反序列化输入，默认False
required	表明该字段在反序列化时必须输入，默认True
default	序列化和反序列化时使用的默认值
allow_null	表明该字段是否允许传入None，默认False
validators	该字段使用的验证器
error_messages	包含错误编号与错误信息的字典
label	用于HTML展示API页面时，显示的字段名称
help_text	用于HTML展示API页面时，显示的字段帮助提示信息
max_length	最大长度
min_lenght	最小长度
allow_blank	是否允许为空
trim_whitespace	是否截断空白字符
max_value	最小值
min_value	最大值
source 指定某个外键的某个字段
"""


"""
from .models import Post
from .serializers import PostSerializer
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser
from django.utils.six import BytesIO
import datetime

# 创建数据(参考 django model 部分)
post = Post(title='Restful 接口入门', create_time=datetime.datetime.now(),
           modified_time=datetime.datetime.now(), body='Restful 接口入门',
           excerpt='Restful 接口入门')
# 保存到数据库
post.save()
# 对 post 实例进行序列化
serializer = PostSerializer(post)
# 通过 serializer.data 查看序列化后的结果，是一个字典
# {'title': 'Restful 接口入门', 'body': 'Restful 接口入门',
# 'create_time': '2018-04-05T21:27:21+08:00', 'modified_time': '2018-04-05T21:27:25+08:00',
# 'excerpt': 'Restful 接口入门'}
print(serializer.data)

# 通过 JSONRenderer 将序列化的数据渲染成 json 格式的数据
content = JSONRenderer().render(serializer.data)
# b'{"title":"Restful 接口入门","body":"Restful 接口入门",
# "create_time":"2018-04-05T21:27:21+08:00",
# "modified_time":"2018-04-05T21:27:25+08:00","excerpt":"Restful 接口入门"}'
print(content)

# 如果将 json 转回字典，需要通过 BytesIO 进行处理
stream = BytesIO(content)
# 打印结果同序列化后的结果
data = JSONParser().parser(stream)

# 将数据转换成为实体类对象
serializer = PostSerializer(data=data)
# 需要检验是否有效数据，类似 Form
serializer.is_valid()
# 经过验证后的数据，返回一个 OrderedDict
# OrderedDict([('title', 'Restful 接口入门'), ('body', 'Restful 接口入门'),
# ('create_time', datetime.datetime(2018, 4, 5, 21, 27, 21,
# tzinfo=<DstTzInfo 'Asia/Shanghai' CST+8:00:00 STD>)),
# ('modified_time', datetime.datetime(2018, 4, 5, 21, 27, 25,
# tzinfo=<DstTzInfo 'Asia/Shanghai' CST+8:00:00 STD>)),
# ('excerpt', 'Restful 接口入门')])
print(serializer.validated_data)
# 保存有效的数据，通常用于 POST 提交的数据信息
serializer.save()

# 除了序列化模型实例，也可以将 queryset 进行序列化，此时需要在 serializer 中加入 many=True
posts = Post.objects.all()
serializer = PostSerializer(posts, many=True)
# 返回 OrderedDict 列表
print(serializer.data)
"""
