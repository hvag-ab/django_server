关于Django多进程多线程详解

django 原生为单线程序，当第一个请求没有完成时，第二个请求辉阻塞，知道第一个请求完成，第二个请求才会执行。

Django 通过线程来实现并发，这也是WSGI普遍的做法

uwsgi --http 0.0.0.0:8000 --file Demo/wsgi.py --processes 4 --threads 2
# processes: 进程数 # processes 和 workers 一样的效果
# threads : 每个进程开的线程数

uwsgi是一个优秀的web server, 但是出于性能和安全性的考虑, 往往会在uwsgi上面再包一层Nginx。
而Nginx是一个异步多进程的服务器, 所以在使用中往往会fork多个nginx的worker进程, 来提高处理request的效率。
worker进程数一般是cpu核心数。


场景1：

2个进程，每个进程1个线程，请求函数中设置了10秒sleep，9个请求同一URL：

结果：

1. 全局变量ID值，在每一个进程中相同，不同进程中不相同

2. 并行只能接受2个请求，同时发起多个请求，则需要排队等待处理

场景2：

1个进程，每个进程2个线程，请求函数中设置了10秒sleep，9个请求同一URL：

结果：

1. 全局变量ID值，在单进程中相同，每个线程中也相同

2. 并行只能接收2个请求，同时发起多个请求，则需要排队等待处理

场景3：

2个进程，每个进程2个线程，请求函数中设置了10秒sleep，9个请求同一URL：

结果：

1. 全局变量ID值，在每一个进程中相同，同一进程中每个线程中也相同，不同进程中不相同

2. 并行只能接收4 ( 2进程* 2 线程 ) 个请求，同时发起多个请求，则需要排队等待处理

总结：

1. 每个WSGI进程会拥有独立的python变量，该进程内线程共享该变量

2. 进程数 乘以 线程数得到同时能够处理的并发请求数

3. 一个固定的线程，正在处理一个请求时，请求未处理结束，不会同时处理另外的请求。

web应用中不要使用全局变量, 在需要全局变量的情况下, 多考虑是否能用数据库替代

并行和并发的区别：

并发，指的是多个事情，在同一时间段内同时发生了。
并行，指的是多个事情，在同一时间点上同时发生了。

并发的多个任务之间是互相抢占资源的。
并行的多个任务之间是不互相抢占资源的、

只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。

多进程的多处理器的python应用可能存在并行,至于并发还是并行,有操作系统决定,如果分配单处理器处理多进程,
那就是并发,如果分配给多处理器那就是并行
